"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable camelcase */
/* eslint-disable @typescript-eslint/no-unused-expressions */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/restrict-plus-operands */
/* eslint-disable no-duplicate-imports */
const chai_1 = require("chai");
const HttpError_1 = require("./HttpError");
const index_1 = require("./index");
const AllExports = __importStar(require("./index"));
const VALID_ERROR_CODES = [
    400, 401, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412,
    413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426,
    428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 511,
];
const EXPORTED_NAMES = Object.keys(AllExports);
const ERROR_CODES = Array.from(Array(500), (e, i) => i + 100);
// eslint-disable-line max-len
const DEFAULT_ERROR_MESSAGE = 'The server encountered an unexpected condition that prevented it from fulfilling the request';
/**
 * Converts objects to strings, for display
 *
 * @param {any} obj
 * @returns {string}
 */
const toString = (obj) => {
    if (Array.isArray(obj) || null === obj) {
        return '' + obj.map(toString);
    }
    else {
        const typeName = Object.prototype.toString
            .call(obj)
            .replace(/[\[\]]/g, '')
            .split(' ')
            .pop();
        if (typeName === 'undefined' || typeName === 'string') {
            return '' + obj;
        }
        else {
            return JSON.stringify(obj);
        }
    }
};
describe('json-http-errors#', () => {
    describe('Custom Error Classes', () => {
        it('Should have a Custom HttpError class for error codes 400 - 511', () => {
            VALID_ERROR_CODES.map(statusNumber => {
                const errorObject = index_1.createError(statusNumber);
                const errorClass = errorObject.constructor;
                const errorClassName = errorClass.name;
                chai_1.expect(errorClassName).to.not.equal('Error');
                chai_1.expect(errorObject.statusCode).to.equal(statusNumber);
                chai_1.expect(errorClass.toString().slice(0, 5)).to.equal('class');
                chai_1.expect(EXPORTED_NAMES.indexOf(errorClassName)).to.be.greaterThan(-1);
            });
        });
    });
    describe('getStatusCode => ', () => {
        const parsedValues = ERROR_CODES.map(c => {
            return [HttpError_1.getStatusCode(c), HttpError_1.getStatusCode(c + .00), HttpError_1.getStatusCode('' + (c + .00))];
        });
        it('Should be a function', () => {
            chai_1.expect(HttpError_1.getStatusCode).to.be.a('function');
        });
        it('Should properly parse integer error codes between 100 and 599', () => {
            const badParsing = parsedValues.find((c, i) => {
                return c[0] !== ERROR_CODES[i];
            });
            chai_1.expect(badParsing).to.be.undefined;
        });
        it('Should not consider invalid status codes as a status code', () => {
            chai_1.expect(HttpError_1.getStatusCode('123fdsaffad')).to.be.undefined;
            chai_1.expect(HttpError_1.getStatusCode('45.16')).to.be.undefined;
        });
        it('Should properly parse status codes as doubles', () => {
            const badParsing = parsedValues.find((c, i) => {
                return c[1] !== ERROR_CODES[i] + .00;
            });
            chai_1.expect(badParsing).to.be.undefined;
        });
        it('Should properly parse string status code values', () => {
            const badParsing = parsedValues.find((c, i) => {
                return c[2] !== ERROR_CODES[i];
            });
            chai_1.expect(badParsing).to.be.undefined;
        });
    });
    describe('parseErrorOptions => ', () => {
        it('Should be a function', () => {
            chai_1.expect(HttpError_1.parseErrorOptions).to.be.a('function');
        });
        const name = 'MyCustomError';
        const title = 'My Custom Error';
        const message = 'This is a custom error';
        const statusCode = 456;
        const testObjs = [
            [
                'abc',
                { message: 'abc' },
            ],
            [
                { foo: 'bar', statusCode: 405 },
                { statusCode: 405 },
            ],
            [
                405,
                { statusCode: 405 },
            ],
            [
                [405, 'Bad Request'],
                { statusCode: 405, message: 'Bad Request' },
            ],
            [
                {
                    body: { error_text: message },
                    message, name, statusCode, title,
                },
                {
                    body: { error_text: message },
                    message, name, title, statusCode,
                },
            ],
            [
                {
                    body: message,
                    name, title, statusCode, message,
                },
                {
                    body: message,
                    name, title, statusCode, message,
                },
            ],
            [
                { name, title, statusCode, message },
                {
                    name, title, statusCode, message,
                },
            ],
        ];
        testObjs.map(testPair => {
            const [data, expected] = testPair;
            const dataStr = toString(data);
            const expectedStr = toString(expected);
            it(`parseErrorOptions(${dataStr}) => ${expectedStr}`, () => {
                const actual = Array.isArray(data)
                    ? HttpError_1.parseErrorOptions(...data)
                    : HttpError_1.parseErrorOptions(data);
                chai_1.expect(actual).to.deep.equal(expected);
            });
        });
    });
    describe('HttpError => ', () => {
        it('Should be a class', () => {
            chai_1.expect(index_1.HttpError).to.be.a('function');
            chai_1.expect(index_1.HttpError.toString().slice(0, 5)).to.equal('class');
        });
        it('Should create an instance of the Error class', () => {
            const testErr = new index_1.HttpError(405);
            chai_1.expect(testErr).to.be.instanceOf(Error);
        });
        it('Should accept only a number as constructor parameters', () => {
            const testErr = new index_1.HttpError(405);
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.statusCode).to.equal(405);
        });
        it('Should accept a number and a string as constructor parameters', () => {
            const testErr = new index_1.HttpError(405, 'Bad shit ahead');
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.statusCode).to.equal(405);
            chai_1.expect(testErr.message).to.equal('Bad shit ahead');
            chai_1.expect(testErr.body).to.deep.equal({ error_text: 'Bad shit ahead' });
        });
        it('Should set a 500 error body if the status code is >= 500', () => {
            const testErr = new index_1.HttpError(500);
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.statusCode).to.equal(500);
            chai_1.expect(testErr.body).to.be.undefined;
        });
        it('Should default to a 500 status, if given an invalid status', () => {
            const testErr = new index_1.HttpError(7000);
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.statusCode).to.equal(500);
            chai_1.expect(testErr.message).to.equal(DEFAULT_ERROR_MESSAGE);
        });
        it('Should accept an HttpErrorOptions object as the constructor parameter', () => {
            const testErr = new index_1.HttpError({ statusCode: 405, message: 'Bad shit ahead' });
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.statusCode).to.equal(405);
            chai_1.expect(testErr.message).to.equal('Bad shit ahead');
        });
        it('Should accept an Error object as the constructor parameter', () => {
            const errorObject = new Error('Bad shit ahead');
            const testErr = new index_1.HttpError(errorObject);
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.statusCode).to.equal(500);
            chai_1.expect(testErr.message).to.equal('Bad shit ahead');
        });
        it('Should reflect valid properties when given an HttpErrorOptions object as the constructor parameter', () => {
            const testErr = new index_1.HttpError({
                message: 'This is a custom error',
                name: 'MyCustomError',
                statusCode: 405,
                title: 'My Custom Error',
            });
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.name).to.equal('MyCustomError');
            chai_1.expect(testErr.title).to.equal('My Custom Error');
            chai_1.expect(testErr.statusCode).to.equal(405);
            chai_1.expect(testErr.message).to.equal('This is a custom error');
            chai_1.expect(testErr.body).to.deep.equal({ error_text: 'This is a custom error' });
        });
        it('Should set the body text if given a string in the constructor of a custom class', () => {
            const testErr = new index_1.BadRequest('WTF are you doing?');
            console.log(JSON.stringify(testErr));
            chai_1.expect(testErr).to.be.instanceOf(Error);
            chai_1.expect(testErr.name).to.equal('Error');
            chai_1.expect(testErr.title).to.equal('Bad Request');
            chai_1.expect(testErr.statusCode).to.equal(400);
            chai_1.expect(testErr.message).to.equal('WTF are you doing?');
            chai_1.expect(testErr.body).to.deep.equal({ error_text: 'WTF are you doing?' });
        });
        it('Should be able to set the status using the statusCode property', () => {
            const testErr = new index_1.HttpError(411);
            chai_1.expect(testErr.statusCode).to.equal(411);
            testErr.statusCode = 412;
            chai_1.expect(testErr.statusCode).to.equal(412);
        });
    });
    describe('createError => ', () => {
        it('Should create an instance of a Custom HttpError class if given a recognized Http status code', () => {
            const testObject = index_1.createError(405);
            const comparisonObj = new AllExports.MethodNotAllowed();
            chai_1.expect(testObject.name).to.equal(comparisonObj.name);
            chai_1.expect(testObject.statusCode).to.equal(comparisonObj.statusCode);
            chai_1.expect(testObject.message).to.equal(comparisonObj.message);
        });
        it('Should create a generic HttpError class if given an unrecognized Http status code', () => {
            const testObject = index_1.createError(499);
            chai_1.expect(testObject.name).to.equal('Error');
            chai_1.expect(testObject.statusCode).to.equal(499);
            chai_1.expect(testObject.title).to.equal('Internal Server Error');
        });
    });
});
//# sourceMappingURL=index.spec.js.map